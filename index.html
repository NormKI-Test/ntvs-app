<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NORMKI ‚Äì Tekton Photo Verification</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-main: #020617;
      --bg-elevated: #020617;
      --border-soft: rgba(51, 65, 85, 0.9);
      --accent: #2563eb;
      --accent-soft: #60a5fa;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI",
        Roboto, sans-serif;
      background: radial-gradient(circle at top, #020617 0%, #020617 55%, #02010a 100%);
      color: var(--text-main);
      min-height: 100vh;
      overflow: hidden;
    }

    /* HEADER */

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 14px 22px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1000;
      background: linear-gradient(
        to bottom,
        rgba(15, 23, 42, 0.98),
        rgba(15, 23, 42, 0.7),
        transparent
      );
      backdrop-filter: blur(16px);
      border-bottom: 1px solid rgba(30, 64, 175, 0.45);
    }

    .logo-wrap {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-mark {
      width: 32px;
      height: 32px;
      border-radius: 10px;
      border: 1px solid rgba(37, 99, 235, 0.9);
      background: radial-gradient(circle at top, #020617, #020617);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.12em;
      color: var(--text-main);
      box-shadow: 0 0 18px rgba(37, 99, 235, 0.6);
    }

    .logo-text {
      display: flex;
      flex-direction: column;
    }

    .logo-main {
      font-size: 17px;
      font-weight: 700;
      letter-spacing: 0.2em;
    }

    .logo-sub {
      font-size: 11px;
      opacity: 0.7;
    }

    .icon-button {
      width: 38px;
      height: 38px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: #020617;
      color: var(--text-main);
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .icon-button:hover {
      background: #0b1120;
      transform: translateY(-1px);
    }

    /* MAIN / HERO */

    .main-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 92px 18px 24px;
      position: relative;
      z-index: 2;
    }

    .hero-card {
      width: 100%;
      max-width: 520px;
      border-radius: 22px;
      padding: 22px 22px 20px;
      background: var(--bg-elevated);
      border: 1px solid var(--border-soft);
      box-shadow:
        0 24px 60px rgba(15, 23, 42, 0.95),
        0 0 0 1px rgba(15, 23, 42, 1);
      position: relative;
      transition: opacity 0.35s ease, transform 0.35s ease;
      animation: heroFloat 4s ease-in-out infinite;
    }

    .hero-card.off {
      opacity: 0;
      transform: translateY(16px) scale(0.98);
      pointer-events: none;
    }

    @keyframes heroFloat {
      0% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-4px) scale(1.005); }
      100% { transform: translateY(0) scale(1); }
    }

    .hero-content {
      position: relative;
      z-index: 1;
    }

    .hero-eyebrow {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-muted);
      margin-bottom: 8px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .hero-eyebrow-pill {
      font-size: 10px;
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: #020617;
      color: var(--text-main);
    }

    .hero-title {
      font-size: 24px;
      line-height: 1.3;
      font-weight: 700;
      margin-bottom: 8px;
      color: #f9fafb;
    }

    .hero-title span {
      color: var(--accent-soft);
    }

    .hero-sub {
      font-size: 13px;
      color: #d1d5db;
      line-height: 1.6;
      margin-bottom: 16px;
    }

    .hero-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 18px;
    }

    .badge {
      font-size: 11px;
      padding: 6px 9px;
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: #020617;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
      color: var(--text-main);
    }

    .badge-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
    }

    .hero-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }

    .start-button {
      flex: 1;
      padding: 12px 16px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 999px;
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      color: #f9fafb;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow:
        0 14px 34px rgba(15, 23, 42, 0.95),
        0 0 0 1px rgba(15, 23, 42, 1);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }

    .start-button::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(
        120deg,
        transparent,
        rgba(255, 255, 255, 0.2),
        transparent
      );
      transform: translateX(-120%);
      opacity: 0;
    }

    .start-button:hover::after {
      opacity: 1;
      animation: btnShine 0.9s ease-out;
    }

    @keyframes btnShine {
      0% { transform: translateX(-120%); }
      100% { transform: translateX(120%); }
    }

    .start-button:hover {
      transform: translateY(-1px);
    }

    .start-button:disabled {
      opacity: 0.65;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    .start-button span.icon {
      font-size: 16px;
    }

    .loader-wrap {
      display: none;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .loader-wrap.active {
      display: inline-flex;
    }

    .loader-spinner {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 2px solid rgba(75, 85, 99, 0.9);
      border-top-color: var(--accent);
      animation: spin 0.9s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .helper-text {
      font-size: 11px;
      opacity: 0.75;
      line-height: 1.5;
      color: var(--text-muted);
    }

    .helper-text b {
      opacity: 1;
      color: var(--text-main);
    }

    /* VIDEO & CAPTURE */

    .video-container {
      position: fixed;
      inset: 0;
      z-index: 1;
      display: none;
    }

    .video-container.active {
      display: block;
    }

    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #020617;
    }

    .capture-button {
      position: fixed;
      bottom: 34px;
      left: 50%;
      transform: translateX(-50%);
      width: 78px;
      height: 78px;
      border-radius: 999px;
      border: 3px solid rgba(148, 163, 184, 0.95);
      background: #f9fafb;
      cursor: pointer;
      z-index: 120;
      display: none;
      transition: all 0.15s ease;
      box-shadow:
        0 12px 32px rgba(0, 0, 0, 0.85),
        0 0 0 1px rgba(15, 23, 42, 1);
      animation: pulseCapture 1.8s ease-in-out infinite;
    }

    .capture-button::before {
      content: "";
      position: absolute;
      inset: 7px;
      border-radius: 999px;
      background: #e5e7eb;
    }

    .capture-button:active:not(:disabled) {
      transform: translateX(-50%) scale(0.96);
    }

    .capture-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      animation: none;
    }

    @keyframes pulseCapture {
      0% { box-shadow: 0 12px 32px rgba(0, 0, 0, 0.9); }
      50% { box-shadow: 0 12px 42px rgba(37, 99, 235, 0.35); }
      100% { box-shadow: 0 12px 32px rgba(0, 0, 0, 0.9); }
    }

    .status-text {
      position: fixed;
      bottom: 126px;
      left: 50%;
      transform: translateX(-50%);
      padding: 9px 16px;
      background: rgba(15, 23, 42, 0.96);
      border-radius: 999px;
      font-size: 13px;
      z-index: 120;
      display: none;
      border: 1px solid rgba(75, 85, 99, 0.9);
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.95);
      color: var(--text-main);
    }

    .status-text.pulse {
      animation: statusPulse 0.18s ease-out;
    }

    @keyframes statusPulse {
      0% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.03); }
      100% { transform: translateX(-50%) scale(1); }
    }

    /* BACK BUTTON IN CAMERA */

    .overlay-back-btn {
      position: fixed;
      top: 14px;
      left: 14px;
      z-index: 130;
      display: none;
      width: 38px;
      height: 38px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.96);
      color: var(--text-main);
      font-size: 18px;
      cursor: pointer;
      align-items: center;
      justify-content: center;
    }

    .overlay-back-btn.visible {
      display: flex;
    }

    /* FLASH OVERLAY */

    .flash-overlay {
      position: fixed;
      inset: 0;
      background: #ffffff;
      opacity: 0;
      pointer-events: none;
      z-index: 200;
    }

    .flash-overlay.active {
      animation: flashBlink 0.16s ease-out;
    }

    @keyframes flashBlink {
      0% { opacity: 0; }
      30% { opacity: 0.3; }
      100% { opacity: 0; }
    }

    /* PREVIEW */

    .preview-container {
      position: fixed;
      inset: 0;
      background: #020617;
      z-index: 500;
      display: none;
      flex-direction: column;
      align-items: center;
      padding: 90px 18px 20px;
      overflow-y: auto;
    }

    .preview-container.active {
      display: flex;
    }

    .preview-inner {
      width: 100%;
      max-width: 520px;
      animation: previewFade 0.22s ease-out;
    }

    @keyframes previewFade {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .preview-header {
      width: 100%;
      margin-bottom: 16px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 10px;
    }

    .preview-title {
      font-size: 18px;
      font-weight: 600;
      color: #f9fafb;
    }

    .preview-sub {
      font-size: 11px;
      opacity: 0.72;
      margin-top: 4px;
      color: var(--text-muted);
    }

    .preview-grid {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 10px;
    }

    .preview-block {
      background: #020617;
      border-radius: 16px;
      padding: 10px 10px 12px;
      border: 1px solid rgba(51, 65, 85, 0.95);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.98);
    }

    .preview-label {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 6px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
    }

    .preview-image {
      width: 100%;
      max-height: 52vh;
      object-fit: contain;
      border-radius: 10px;
      background: #000;
    }

    .preview-actions {
      width: 100%;
      display: flex;
      gap: 10px;
      margin-top: 6px;
    }

    .btn-pill {
      flex: 1;
      padding: 10px 12px;
      font-size: 13px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.15s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      color: #f9fafb;
      font-weight: 600;
      box-shadow:
        0 12px 30px rgba(15, 23, 42, 1),
        0 0 0 1px rgba(15, 23, 42, 1);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: #020617;
      color: var(--text-main);
      border: 1px solid rgba(75, 85, 99, 0.95);
    }

    .btn-secondary:hover {
      transform: translateY(-1px);
    }

    canvas {
      display: none;
    }

    @media (min-width: 700px) {
      .main-container {
        padding-top: 110px;
      }
      .hero-card {
        padding: 24px 24px 22px;
      }
      .hero-title {
        font-size: 26px;
      }
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="logo-wrap">
      <div class="logo-mark">NK</div>
      <div class="logo-text">
        <div class="logo-main">NORMKI</div>
        <div class="logo-sub">Tekton Photo Verification</div>
      </div>
    </div>
    <button class="icon-button" id="infoBtn">?</button>
  </header>

  <main class="main-container">
    <div class="hero-card" id="heroCard">
      <div class="hero-content">
        <div class="hero-eyebrow">
          NTVS
          <span class="hero-eyebrow-pill">Rolling-Shutter Pattern</span>
        </div>
        <div class="hero-title">
          <span>Verifizierte</span> Beweisfotos f√ºr Baustellen & Geb√§ude.
        </div>
        <div class="hero-sub">
          NORMKI erstellt Beweisfotos mit einem Linien-Code direkt im Bild.
          Alle Metadaten (Zeit, GPS, Hash, ID) landen im PDF-Protokoll ‚Äì nicht als Klartext auf dem Foto.
        </div>

        <div class="hero-badges">
          <div class="badge">
            <span class="badge-dot"></span> Linien-Code im Bild
          </div>
          <div class="badge">
            üîí SHA-256 Hash
          </div>
          <div class="badge">
            üìÑ LOG- & Bilder-PDF
          </div>
        </div>

        <div class="hero-footer">
          <button id="startBtn" class="start-button">
            <span class="icon">‚óé</span>
            Scan starten
          </button>
          <div id="loaderWrap" class="loader-wrap">
            <div class="loader-spinner"></div>
            <span>Initialisierung‚Ä¶</span>
          </div>
        </div>

        <div class="helper-text">
          Nutzt <b>Kamera</b> und ‚Äì wenn freigegeben ‚Äì <b>Standort</b>.
          Blockiertes GPS wird durch einen Demo-Standort ersetzt, damit der
          Ablauf nicht h√§ngen bleibt.
        </div>
      </div>
    </div>
  </main>

  <div id="videoContainer" class="video-container">
    <video id="video" autoplay playsinline></video>
  </div>

  <button id="backCameraBtn" class="overlay-back-btn">‚Üê</button>

  <button id="captureBtn" class="capture-button"></button>

  <div id="statusText" class="status-text"></div>

  <div id="flashOverlay" class="flash-overlay"></div>

  <div id="previewContainer" class="preview-container">
    <div class="preview-inner">
      <div class="preview-header">
        <div>
          <div class="preview-title">Verifizierte Aufnahme</div>
          <div class="preview-sub">
            Du kannst mehrere Fotos machen. LOG-PDF und Bilder-PDF fassen alle Shots der Session zusammen.
          </div>
        </div>
        <span style="font-size:11px; color:#6b7280;">NORMKI ‚Ä¢ Tekton</span>
      </div>

      <div class="preview-grid">
        <div class="preview-block">
          <div class="preview-label">Mit Linien-Code</div>
          <img id="previewWithPattern" class="preview-image" alt="NORMKI Verified" />
        </div>
        <div class="preview-block">
          <div class="preview-label">Original</div>
          <img id="previewWithoutPattern" class="preview-image" alt="Original" />
        </div>
      </div>

      <div id="previewMeta" style="font-size:11px;color:#9ca3af;margin:4px 2px 4px;"></div>

      <div class="preview-actions">
        <button id="previewBackBtn" class="btn-pill btn-secondary">Neues Foto</button>
        <button id="downloadLogBtn" class="btn-pill btn-primary">‚¨áÔ∏è LOG-PDF</button>
      </div>
      <div class="preview-actions">
        <button id="downloadImagesBtn" class="btn-pill btn-secondary">‚¨áÔ∏è Bilder-PDF</button>
      </div>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <!-- jsPDF f√ºr PDF-Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    const NORMKI_PATTERN = [1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0];

    let stream = null;
    let gps = null;
    const captures = [];

    const startBtn = document.getElementById("startBtn");
    const captureBtn = document.getElementById("captureBtn");
    const previewBackBtn = document.getElementById("previewBackBtn");
    const backCameraBtn = document.getElementById("backCameraBtn");
    const downloadLogBtn = document.getElementById("downloadLogBtn");
    const downloadImagesBtn = document.getElementById("downloadImagesBtn");
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const videoContainer = document.getElementById("videoContainer");
    const statusText = document.getElementById("statusText");
    const loaderWrap = document.getElementById("loaderWrap");
    const previewContainer = document.getElementById("previewContainer");
    const previewWithPattern = document.getElementById("previewWithPattern");
    const previewWithoutPattern = document.getElementById("previewWithoutPattern");
    const previewMeta = document.getElementById("previewMeta");
    const infoBtn = document.getElementById("infoBtn");
    const heroCard = document.getElementById("heroCard");
    const flashOverlay = document.getElementById("flashOverlay");

    const isIOS = /iP(ad|hone|od)/.test(navigator.userAgent);
    const supportsSubtle = !!(window.crypto && window.crypto.subtle);

    function vibrate(pattern = [80, 30, 80]) {
      if (!navigator.vibrate || isIOS) {
        statusText.classList.remove("pulse");
        void statusText.offsetWidth;
        statusText.classList.add("pulse");
        return;
      }
      navigator.vibrate(pattern);
    }

    function showStatus(text) {
      statusText.textContent = text;
      statusText.style.display = "block";
    }

    function hideStatus() {
      statusText.style.display = "none";
      statusText.classList.remove("pulse");
    }

    function showLoader() {
      loaderWrap.classList.add("active");
    }

    function hideLoader() {
      loaderWrap.classList.remove("active");
    }

    function triggerFlash() {
      flashOverlay.classList.remove("active");
      void flashOverlay.offsetWidth;
      flashOverlay.classList.add("active");
    }

    async function getGPS() {
      return new Promise((resolve) => {
        if (!navigator.geolocation) {
          resolve({ lat: 48.210033, lng: 16.363449, demo: true });
          return;
        }

        const timeout = setTimeout(() => {
          resolve({ lat: 48.210033, lng: 16.363449, demo: true });
        }, 3000);

        navigator.geolocation.getCurrentPosition(
          (position) => {
            clearTimeout(timeout);
            resolve({
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              demo: false,
            });
          },
          () => {
            clearTimeout(timeout);
            resolve({ lat: 48.210033, lng: 16.363449, demo: true });
          },
          {
            enableHighAccuracy: true,
            timeout: 2500,
            maximumAge: 0,
          }
        );
      });
    }

    async function startCamera() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showStatus("Kamera wird vom Browser nicht unterst√ºtzt.");
        return false;
      }

      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          },
          audio: false,
        });

        video.srcObject = stream;

        await new Promise((resolve) => {
          if (video.readyState >= 2) return resolve();
          video.onloadedmetadata = () => resolve();
        });

        videoContainer.classList.add("active");
        captureBtn.style.display = "block";
        backCameraBtn.classList.add("visible");
        showStatus("Bereit ‚Äì Bild ausrichten und ausl√∂sen.");
        vibrate([100, 30, 100]);

        heroCard.classList.add("off");
        return true;
      } catch (err) {
        console.error(err);
        showStatus("Kamera-Zugriff verweigert oder nicht verf√ºgbar.");
        return false;
      }
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach((t) => t.stop());
        stream = null;
      }
      video.srcObject = null;
      videoContainer.classList.remove("active");
      captureBtn.style.display = "none";
      backCameraBtn.classList.remove("visible");
    }

    async function executeFlashPattern() {
      if (!stream) return;
      const track = stream.getVideoTracks()[0];
      if (!track) return;

      const capabilities = track.getCapabilities ? track.getCapabilities() : {};
      if (!capabilities.torch) {
        return;
      }

      for (let i = 0; i < NORMKI_PATTERN.length; i++) {
        const bit = NORMKI_PATTERN[i];
        try {
          await track.applyConstraints({
            advanced: [{ torch: bit === 1 }],
          });
        } catch (e) {
          console.log("Torch-Fehler:", e);
          break;
        }

        if (i % 5 === 0) vibrate([40]);
        await new Promise((resolve) => setTimeout(resolve, 50));
      }

      try {
        await track.applyConstraints({ advanced: [{ torch: false }] });
      } catch (_) {}
    }

    async function computeCaptureHash(imageDataUrl, timestampIso, gpsObj, pattern) {
      const base64 = imageDataUrl.split(",")[1] || "";
      const binary = atob(base64);
      const len = binary.length;
      const imageBytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        imageBytes[i] = binary.charCodeAt(i);
      }

      const metaString = JSON.stringify({
        timestampIso,
        gps: gpsObj,
        pattern
      });
      const metaBytes = new TextEncoder().encode(metaString);

      const combined = new Uint8Array(imageBytes.length + metaBytes.length);
      combined.set(imageBytes, 0);
      combined.set(metaBytes, imageBytes.length);

      const digest = await crypto.subtle.digest("SHA-256", combined);
      const hashArray = Array.from(new Uint8Array(digest));
      return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
    }

    function buildLineCodeBytes(timestampIso, gpsObj, hashHex) {
      const tsSec = Math.floor(new Date(timestampIso).getTime() / 1000);

      const lat = gpsObj && typeof gpsObj.lat === "number" ? gpsObj.lat : 0;
      const lng = gpsObj && typeof gpsObj.lng === "number" ? gpsObj.lng : 0;

      const latScaled = Math.max(
        0,
        Math.min(
          65535,
          Math.round(((lat + 90) / 180) * 65535)
        )
      );

      const lngScaled = Math.max(
        0,
        Math.min(
          65535,
          Math.round(((lng + 180) / 360) * 65535)
        )
      );

      const safeHash = (hashHex || "").padEnd(8, "0");
      const hashBytes = [];
      for (let i = 0; i < 8; i += 2) {
        hashBytes.push(parseInt(safeHash.slice(i, i + 2), 16));
      }

      const bytes = [];
      bytes.push((tsSec >>> 24) & 0xff);
      bytes.push((tsSec >>> 16) & 0xff);
      bytes.push((tsSec >>> 8) & 0xff);
      bytes.push(tsSec & 0xff);

      bytes.push((latScaled >>> 8) & 0xff);
      bytes.push(latScaled & 0xff);

      bytes.push((lngScaled >>> 8) & 0xff);
      bytes.push(lngScaled & 0xff);

      bytes.push(...hashBytes);

      return bytes; // 12 Bytes
    }

    function drawLineCode(ctx, canvasWidth, baseY, bytes) {
      const rows = bytes.length;
      const cols = 8;

      const cellHeight = 6;
      const gapY = 2;
      const cellWidth = 10;
      const gapX = 3;

      const xStart = 24;

      const totalHeightBg = rows * (cellHeight + gapY) + 8;
      ctx.fillStyle = "rgba(0, 0, 0, 0.35)";
      ctx.fillRect(0, baseY - 8, canvasWidth, totalHeightBg + 16);

      for (let row = 0; row < rows; row++) {
        const b = bytes[row];
        const yTop = baseY + row * (cellHeight + gapY);

        for (let col = 0; col < cols; col++) {
          const bit = (b >> (7 - col)) & 1;
          const xLeft = xStart + col * (cellWidth + gapX);

          if (bit === 1) {
            ctx.fillStyle = "rgba(96, 165, 250, 0.9)";
            ctx.fillRect(xLeft, yTop, cellWidth, cellHeight);
          } else {
            ctx.fillStyle = "rgba(30, 64, 175, 0.25)";
            ctx.fillRect(
              xLeft,
              yTop + cellHeight * 0.3,
              cellWidth,
              cellHeight * 0.4
            );
          }
        }
      }

      const totalHeight = rows * (cellHeight + gapY);
      ctx.strokeStyle = "rgba(51, 65, 85, 0.95)";
      ctx.lineWidth = 1;
      ctx.strokeRect(
        xStart - 6,
        baseY - 4,
        cols * (cellWidth + gapX) - gapX + 12,
        totalHeight + 8
      );

      return totalHeight + 8;
    }

    async function capturePhoto() {
      if (!stream) {
        showStatus("Keine aktive Kamera.");
        return;
      }

      captureBtn.disabled = true;
      showStatus("Pattern wird angewendet‚Ä¶");
      vibrate([70]);

      await executeFlashPattern();
      triggerFlash();

      canvas.width = video.videoWidth || 1920;
      canvas.height = video.videoHeight || 1080;
      const ctx = canvas.getContext("2d");

      const timestampIso = new Date().toISOString();

      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const originalImage = canvas.toDataURL("image/png");

      let hashHex = null;
      if (!supportsSubtle) {
        showStatus("Hash-Berechnung im Browser nicht m√∂glich. Bitte modernen Browser / HTTPS verwenden.");
      } else {
        try {
          hashHex = await computeCaptureHash(
            originalImage,
            timestampIso,
            gps,
            NORMKI_PATTERN
          );
        } catch (e) {
          console.error("Hash-Berechnung fehlgeschlagen:", e);
        }
      }

      const tsSec = Math.floor(new Date(timestampIso).getTime() / 1000);
      const tsBase36 = tsSec.toString(36).toUpperCase();
      const hashShort = hashHex
        ? hashHex.slice(0, 12).toUpperCase()
        : NORMKI_PATTERN.join("");

      const verificationId = `NTVS1-T${tsBase36}-H${hashShort}`;
      const isDemo = !gps || gps.demo;

      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      const lineCodeBytes = buildLineCodeBytes(
        timestampIso,
        gps || { lat: 0, lng: 0, demo: true },
        hashHex
      );

      const lineCodeHex = Array.from(lineCodeBytes)
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");

      const codeBaseY = 40;
      const codeHeight = drawLineCode(ctx, canvas.width, codeBaseY, lineCodeBytes);

      const patternTopMargin = 24;
      const startY = codeBaseY + codeHeight + patternTopMargin;
      const patternHeight = canvas.height - startY - 32;
      const lineHeight = patternHeight / NORMKI_PATTERN.length;

      ctx.shadowBlur = 8;
      ctx.shadowColor = "rgba(96, 165, 250, 0.85)";

      for (let i = 0; i < NORMKI_PATTERN.length; i++) {
        const y = startY + i * lineHeight;
        const active = NORMKI_PATTERN[i] === 1;
        const opacity = active ? 0.6 : 0.18;

        ctx.strokeStyle = `rgba(96, 165, 250, ${opacity})`;
        ctx.lineWidth = active ? 4 : 2;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      ctx.shadowBlur = 0;

      const verifiedImage = canvas.toDataURL("image/png");

      const shot = {
        verificationId,
        caseId: verificationId,
        timestampIso,
        hash: hashHex,
        hashShort,
        gps,
        demo: isDemo,
        pattern: NORMKI_PATTERN.slice(),
        lineCodeHex,
        verifiedImage,
        originalImage
      };

      captures.push(shot);

      previewWithPattern.src = verifiedImage;
      previewWithoutPattern.src = originalImage;
      if (previewMeta) {
        previewMeta.textContent =
          `Shot ${captures.length} ¬∑ ID: ${verificationId} ¬∑ GPS: ${isDemo ? "Demo" : "Echt"}`;
      }
      previewContainer.classList.add("active");

      hideStatus();
      vibrate([100, 40, 100]);
    }

    function downloadLogPdfForAll() {
      if (!window.jspdf) {
        alert("PDF-Export im Browser nicht verf√ºgbar.");
        return;
      }
      if (!captures.length) {
        alert("Keine Aufnahmen in dieser Session.");
        return;
      }

      vibrate([100, 30, 100]);

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF("p", "mm", "a4");
      const margin = 15;
      const lineHeight = 5;
      let y = 20;

      doc.setFont("helvetica", "bold");
      doc.setFontSize(14);
      doc.text("NORMKI Tekton ‚Äì Capture Log", margin, y);
      y += 10;

      doc.setFont("helvetica", "normal");
      doc.setFontSize(9);

      captures.forEach((c, idx) => {
        const blockBaseLines = 9;
        const blockHeight = blockBaseLines * lineHeight + 8;
        if (y + blockHeight > 280) {
          doc.addPage();
          y = 20;
        }

        doc.setFont("helvetica", "bold");
        doc.text(`#${idx + 1} ‚Äì ID: ${c.verificationId}`, margin, y);
        y += lineHeight;

        doc.setFont("helvetica", "normal");
        doc.text(`Zeit (ISO): ${c.timestampIso}`, margin, y); y += lineHeight;

        const hashFull = c.hash || "-";
        doc.text(
          `Hash (SHA-256): ${hashFull !== "-" ? hashFull.slice(0, 32) + "..." : "-"}`,
          margin,
          y
        );
        y += lineHeight;

        doc.text(`Hash Short: ${c.hashShort || "-"}`, margin, y); y += lineHeight;

        if (c.gps && typeof c.gps.lat === "number") {
          doc.text(
            `GPS: ${c.gps.lat.toFixed(6)}, ${c.gps.lng.toFixed(6)}${c.demo ? " (Demo)" : ""}`,
            margin,
            y
          );
        } else {
          doc.text("GPS: -", margin, y);
        }
        y += lineHeight;

        doc.text(`Demo-GPS: ${c.demo ? "Ja" : "Nein"}`, margin, y); y += lineHeight;
        doc.text(`Pattern: ${c.pattern.join("")}`, margin, y); y += lineHeight;

        if (c.lineCodeHex) {
          doc.text("LineCode (Hex, 12 Bytes):", margin, y); y += lineHeight;
          const lc = c.lineCodeHex.toUpperCase();
          const chunk = 32;
          for (let i = 0; i < lc.length; i += chunk) {
            doc.text(lc.slice(i, i + chunk), margin + 4, y);
            y += lineHeight;
          }
        }

        y += lineHeight;
      });

      doc.save(`normki-log-${Date.now()}.pdf`);
    }

    function downloadImagesPdfForAll() {
      if (!window.jspdf) {
        alert("PDF-Export im Browser nicht verf√ºgbar.");
        return;
      }
      if (!captures.length) {
        alert("Keine Aufnahmen in dieser Session.");
        return;
      }

      vibrate([100, 30, 100]);

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF("p", "mm", "a4");
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const margin = 15;
      const imgMaxWidth = pageWidth - 2 * margin;

      captures.forEach((c, idx) => {
        if (idx > 0) doc.addPage();

        let y = 15;
        doc.setFont("helvetica", "bold");
        doc.setFontSize(12);
        doc.text(`Case/ID: ${c.verificationId}`, margin, y);
        y += 7;

        doc.setFont("helvetica", "normal");
        doc.setFontSize(10);
        doc.text("Verified (Linien-Code)", margin, y);
        y += 4;

        const imgProps1 = doc.getImageProperties(c.verifiedImage);
        const imgHeight1 = (imgProps1.height * imgMaxWidth) / imgProps1.width;
        doc.addImage(c.verifiedImage, "PNG", margin, y, imgMaxWidth, imgHeight1);
        y += imgHeight1 + 8;

        if (y + 20 < pageHeight) {
          doc.setFont("helvetica", "normal");
          doc.setFontSize(10);
          doc.text("Original", margin, y);
          y += 4;
          const imgProps2 = doc.getImageProperties(c.originalImage);
          const imgHeight2 = (imgProps2.height * imgMaxWidth) / imgProps2.width;
          doc.addImage(c.originalImage, "PNG", margin, y, imgMaxWidth, imgHeight2);
        }
      });

      doc.save(`normki-images-${Date.now()}.pdf`);
    }

    function backToCamera() {
      vibrate([40]);
      previewContainer.classList.remove("active");
      captureBtn.disabled = false;
      showStatus("Bereit ‚Äì neues Foto aufnehmen.");
    }

    function backToHero() {
      vibrate([40]);
      stopCamera();
      hideStatus();
      heroCard.classList.remove("off");
      startBtn.disabled = false;
    }

    startBtn.addEventListener("click", async () => {
      startBtn.disabled = true;
      showLoader();
      showStatus("GPS wird gepr√ºft‚Ä¶");
      gps = await getGPS();
      showStatus("Kamera wird gestartet‚Ä¶");

      const camOk = await startCamera();
      hideLoader();

      if (!camOk) {
        startBtn.disabled = false;
        heroCard.classList.remove("off");
      }
    });

    captureBtn.addEventListener("click", capturePhoto);
    previewBackBtn.addEventListener("click", backToCamera);
    backCameraBtn.addEventListener("click", backToHero);
    downloadLogBtn.addEventListener("click", downloadLogPdfForAll);
    downloadImagesBtn.addEventListener("click", downloadImagesPdfForAll);

    infoBtn.addEventListener("click", () => {
      vibrate([40]);
      alert(
        "NORMKI Tekton\n\n" +
          "Jede Aufnahme erzeugt zwei Bilder: Original und ein Bild mit Linien-Code.\n" +
          "Der Linien-Code encodiert Zeit, GPS (falls freigegeben) und einen Hash-Short.\n" +
          "LOG-PDF enth√§lt alle Metadaten, Bilder-PDF alle Original- und Verified-Fotos der Session."
      );
    });

    console.log("NORMKI NTVS System (Multi-Foto, LOG- & Bilder-PDF) geladen und bereit.");
  </script>
</body>
</html>
